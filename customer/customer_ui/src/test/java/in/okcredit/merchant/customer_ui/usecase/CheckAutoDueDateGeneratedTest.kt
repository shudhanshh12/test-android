package `in`.okcredit.merchant.customer_ui.usecase

import `in`.okcredit.backend._offline.usecase.DueInfoParticularCustomerSyncer
import `in`.okcredit.backend.contract.GetCustomer
import `in`.okcredit.merchant.contract.GetActiveBusinessId
import `in`.okcredit.merchant.customer_ui.TestData
import com.nhaarman.mockitokotlin2.any
import com.nhaarman.mockitokotlin2.anyOrNull
import com.nhaarman.mockitokotlin2.eq
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import io.mockk.every
import io.mockk.mockkStatic
import io.reactivex.Completable
import io.reactivex.Observable
import io.reactivex.Single
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.runBlocking
import org.junit.Before
import org.junit.Test
import tech.okcredit.android.base.preferences.DefaultPreferences

class CheckAutoDueDateGeneratedTest {
    private val dueInfoParticularCustomerSyncer: DueInfoParticularCustomerSyncer = mock()
    private val getCustomerDueInfo: GetCustomerDueInfo = mock()
    private val rxSharedPreference: DefaultPreferences = mock()
    private val getCustomer: GetCustomer = mock()
    private val getActiveBusinessId: GetActiveBusinessId = mock()

    private val SHOULD_SHOW_AUTO_DUE_DATE = "should_show_auto_due_date"
    private val checkAutoDueDateGenerated = CheckAutoDueDateGenerated(
        dueInfoParticularCustomerSyncer = { dueInfoParticularCustomerSyncer },
        getCustomerDueInfo = { getCustomerDueInfo },
        rxSharedPreference = { rxSharedPreference },
        getCustomer = { getCustomer },
        getActiveBusinessId = { getActiveBusinessId }
    )

    @Before
    fun setup() {
        mockkStatic(Dispatchers::class)
        every { Dispatchers.Default } returns Dispatchers.Unconfined
    }

    @Test
    fun `execute() should return auto generated due info`() {
        val customerId = "customer_id"
        val customer = TestData.CUSTOMER.copy(balanceV2 = -2)
        val dueInfo = TestData.DUE_INFO
        val isAutoDueDateShown = false
        val businessId = "business-id"
        whenever(getCustomer.execute(customerId)).thenReturn(Observable.just(customer))
        whenever(rxSharedPreference.getBoolean(eq(SHOULD_SHOW_AUTO_DUE_DATE + customerId), any(), anyOrNull()))
            .thenReturn(flowOf(isAutoDueDateShown))
        whenever(dueInfoParticularCustomerSyncer.execute(customerId, businessId)).thenReturn(Completable.complete())
        whenever(getCustomerDueInfo.execute(GetCustomerDueInfo.Request(customerId))).thenReturn(Observable.just(dueInfo))
        whenever(getActiveBusinessId.execute()).thenReturn(Single.just(businessId))
        val testObserver = checkAutoDueDateGenerated.execute(customerId).test()

        testObserver.assertValues(dueInfo.activeDate)

        testObserver.dispose()
    }

    @Test
    fun `execute() should call sync if customer has due and autoDue date not shown`() {
        val customerId = "customer_id"
        val businessId = "business-id"
        val customer = TestData.CUSTOMER.copy(balanceV2 = -2)
        val dueInfo = TestData.DUE_INFO.copy(isAutoGenerated = false, isDueActive = false)
        val isAutoDueDateShown = false
        whenever(getCustomer.execute(customerId)).thenReturn(Observable.just(customer))
        whenever(rxSharedPreference.getBoolean(eq(SHOULD_SHOW_AUTO_DUE_DATE + customerId), any(), anyOrNull()))
            .thenReturn(flowOf(isAutoDueDateShown))
        whenever(getActiveBusinessId.execute()).thenReturn(Single.just(businessId))
        whenever(dueInfoParticularCustomerSyncer.execute(customerId, businessId)).thenReturn(Completable.complete())
        whenever(getCustomerDueInfo.execute(GetCustomerDueInfo.Request(customerId))).thenReturn(Observable.just(dueInfo))
        val testObserver = checkAutoDueDateGenerated.execute(customerId).test()

        verify(dueInfoParticularCustomerSyncer).execute(customerId, businessId)

        testObserver.dispose()
    }

    @Test
    fun `execute() should enable show auto due date if customer has no due`() {
        runBlocking {
            val customerId = "customer_id"
            val businessId = "business-id"
            val customer = TestData.CUSTOMER.copy(balanceV2 = 2)

            whenever(getCustomer.execute(customerId)).thenReturn(Observable.just(customer))
            whenever(getActiveBusinessId.execute()).thenReturn(Single.just(businessId))
            val testObserver = checkAutoDueDateGenerated.execute(customerId).test()

            verify(rxSharedPreference).set(eq(SHOULD_SHOW_AUTO_DUE_DATE + customerId), eq(false), any())

            testObserver.dispose()
        }
    }
}
